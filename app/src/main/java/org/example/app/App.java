/*
 * This source file was generated by the Gradle 'init' task
 */
// IRCTC App
// 1. Gather Functional Requirements
// 1. a. User Registration and Login
// 1. b. Train Search and Booking
// 1. c. Show available seats
// 2. Prepare low level design
// 3. Identify Main Entities and their Attributes
// 3. a. User Entity: userID, name, hashedPassword, ticketsBooked
// 3. b. Ticket Entity: String Ticket, String user, String source, String destination, Datetime, Train train
// 3. c. Train Entity: trainID, trainNumber, departureTime, arrivalTime, List<List<Boolean>> availableSeats
// 4. Creating services - services are classes that contain business logic and uses the entities to perform operations.
// 4. Service - UserBookingService, TrainService
// 4. a. Methods: registerUser(), loginUser(), fetchBookings(), cancelBooking(), bookTicket()
// 4. b. Methods: searchTrains(), getAvailableSeats(), updateSeatAvailability()
// 5. Define Relationships between Entities
// Gradle - build automation tool used for dependency management and project build
//package declaration 
//it is important to match the directory structure
// for proper organization and accessibility of the code.
// In this case, the file is located in 'org/example/app' directory.
// Thus, the package declaration is as follows:
// Whenever you create a new Java file, ensure that the package declaration
// at the top of the file corresponds to its directory structure.
// TCP /IP - Transmission Control Protocol/Internet Protocol is a set of protocols that govern the connection of computer systems to the internet.
// It provides end-to-end communication specifying how data should be packetized, addressed, transmitted, routed, and received.
// HTTP - Hypertext Transfer Protocol is an application protocol for distributed, collaborative, hypermedia information systems.
// It is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access.
// REST - Representational State Transfer is an architectural style for designing networked applications.
// It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.
// TCP 3 way handshake - It is a process used in TCP/IP networks to establish a reliable connection between a client and server before data transmission begins.
// The handshake involves three steps: SYN, SYN-ACK, and ACK.
// 1. SYN: The client sends a SYN (synchronize) packet to the server to initiate a connection.
// 2. SYN-ACK: The server responds with a SYN-ACK (synchronize-acknowledge) packet, acknowledging the client's request and indicating its readiness to establish a connection.
// 3. ACK: The client sends an ACK (acknowledge) packet back to the server, confirming the establishment of the connection.
// Once this three-way handshake is complete, a reliable connection is established, allowing data to be transmitted between the client and server.
// Persistent Connection - A persistent connection, also known as a keep-alive connection, is a network communication channel that remains open for multiple requests and responses between a client and server.
// This allows for the reuse of the same connection for multiple interactions, reducing the overhead of establishing new connections for each request.
// In contrast, a non-persistent connection is closed after a single request-response cycle, requiring a new connection to be established for each subsequent request.
// Persistent connections improve performance by reducing latency and resource consumption, making them particularly beneficial for applications that require frequent communication between clients and servers.
// When a client makes a request to server, if single threaded, server can handle only one request at a time.
// In a multi threaded server, multiple threads can handle multiple requests simultaneously.
// This improves the server's ability to handle concurrent requests, leading to better performance and responsiveness, especially in high-traffic scenarios.
// Multi-threading allows for efficient utilization of server resources, as threads can be created and destroyed as needed to handle incoming requests.
// This is particularly important in web servers, where multiple clients may be making requests at the same time.
// By using multi-threading, servers can provide faster response times and improved scalability.
// In Java, multi-threading is achieved using the Thread class and the Runnable interface.
// Java provides built-in support for multi-threading through the java.lang.Thread class
// and the java.lang.Runnable interface. Developers can create and manage threads using these classes and interfaces,
// allowing for concurrent execution of code within a Java application.
// COntext switching - Context switching is the process of saving and restoring the state of a CPU so that multiple processes or threads can share a single CPU resource.
// It allows the operating system to switch between different tasks, giving the illusion of simultaneous execution.
// When a context switch occurs, the CPU saves the current state of the running process or thread,
// including its program counter, registers, and memory mappings, into a data structure called a process control block (PCB).
// The CPU then loads the state of the next process or thread to be executed from its PCB.
// Context switching is essential for multitasking operating systems, as it enables multiple processes or threads to run concurrently on a single CPU.
// However, context switching incurs some overhead, as saving and restoring the CPU state takes time and resources.
// Excessive context switching can lead to performance degradation, as the CPU spends more time switching between tasks than executing them.
// Therefore, operating systems strive to minimize context switching while still providing responsive multitasking capabilities.
// To overcome the limitiation of context switching, we use thread pools.
// Thread Pools - A thread pool is a collection of pre-instantiated, idle threads that stand ready to be given work.
// Instead of creating a new thread for each task, which can be resource-intensive and time-consuming,
// a thread pool allows for the reuse of existing threads, improving performance and resource utilization.
// When a task is submitted to a thread pool, an available thread from the pool is assigned to execute the task.
// Once the task is completed, the thread returns to the pool and becomes available for future tasks.
// Thread pools are commonly used in server applications, where multiple client requests need to be handled concurrently.
// By using a thread pool, the server can efficiently manage a limited number of threads to handle a large number of requests,
// reducing the overhead associated with thread creation and destruction.
// In Java, server contains queue of requests to be handled by thread pool.
// Each thread in the pool picks up requests from the queue and processes them.
// The difference between java and javascript is that java is a multi-threaded language while javascript is single-threaded language.
// In java, multiple threads can run concurrently while in javascript, only one thread can run at a time.
// This means that in java, multiple tasks can be executed simultaneously while in javascript, tasks are executed one after the other.
// This makes java more suitable for applications that require high concurrency and parallelism, while javascript is more suitable for applications that require simplicity and ease of use.
// Java uses JVM (Java Virtual Machine) to run the code while javascript uses browser or node.js to run the code.
// In javascript, we use event loop to handle asynchronous operations while in java, we use threads to handle asynchronous operations.
// Event Loop - The event loop is a programming construct that allows for non-blocking, asynchronous execution of code.
// It is commonly used in single-threaded environments, such as JavaScript, to handle events and perform I/O operations without blocking the main thread.
// The event loop works by continuously checking a queue of events and executing the corresponding callback functions when events are available.
// When an asynchronous operation is initiated, such as a network request or a timer, the operation is added to the event queue.
// The event loop then picks up events from the queue and executes their associated callback functions when the main thread is idle.
// This allows the main thread to remain responsive and continue processing other events while waiting for asynchronous operations to complete.
// In contrast, multi-threaded environments, such as Java, use threads to handle concurrent execution.
// Each thread can run independently, allowing for parallel execution of code.

package org.example.app;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.UUID;
import java.util.stream.Collectors;

import org.example.app.Util.UserServiceUtil;
import org.example.app.entities.Train;
import org.example.app.entities.User;
import org.example.app.services.UserBookingService;

public class App {

    public static void main(String[] args) throws IOException {
        // We have made a separate Test method to keep the main method clean and readable.
        // this is static method, so we can directly call it using class name without creating object of this class.
        // Test();
        System.out.println("Running Train Booking System...");
        try (Scanner scanner = new Scanner(System.in)) {
            int option = 0;
            // Defining UserBookingService variable here to use it inside try block. We have not initialized it yet.
            UserBookingService userBookingService;
            try {
                // Using default constructor to load all users.
                // userBookingService = new UserBookingService() means we are calling the default constructor of UserBookingService class.
                userBookingService = new UserBookingService();
            } catch (IOException e) {
                e.printStackTrace();              // <‑‑ add this
                System.out.println("There is something wrong");
                return;
            }
            Train trainSelectedForBooking = new Train();

            while (option != 7) {
                System.out.println("1. SignUp User");
                System.out.println("2. Login User");
                System.out.println("3. Fetch Bookings");
                System.out.println("4. Search Trains");
                System.out.println("5. Book a Seat");
                System.out.println("6. Cancel my Booking");
                System.out.println("7. Exit the App");
                System.out.print("Enter your option: ");
                option = scanner.nextInt();
                switch (option) {
                    case 1 -> {
                        // Call Signup user method
                        System.out.println(" Enter the username to signup");
                        String nameToSignup = scanner.next();
                        System.out.println(" Enter the password to signup");
                        String passwordToSignup = scanner.next();
                        User userToSignup = new User(nameToSignup, passwordToSignup, UserServiceUtil.hashPassword(passwordToSignup), new ArrayList<>(), UUID.randomUUID().toString());
                        userBookingService.signUp(userToSignup);
                    }
                    case 2 -> {
                        // Call login user method
                        // Here we are taking username and password input from user to login.
                        // And creating a user object with that username and password.
                        // And then passing that user object to the constructor of UserBookingService class to initialize the user field of that class.
                        // Then we are calling the loginUser method of UserBookingService class to check if the user exists in the user list.
                        System.out.println(" Enter the username to login");
                        String nameToLogin = scanner.next();
                        System.out.println(" Enter the password to login");
                        String passwordToLogin = scanner.next();
                        User userToLogin = new User(nameToLogin, passwordToLogin, UserServiceUtil.hashPassword(passwordToLogin), new ArrayList<>(), UUID.randomUUID().toString());
                        try {
                            userBookingService = new UserBookingService(userToLogin);
                            Boolean loginSuccess = userBookingService.loginUser();
                            if (loginSuccess) {
                                System.out.println("Login Successful");
                            } else {
                                System.out.println("Login Failed");
                            }
                        } catch (IOException e) {
                            System.out.println("There is something wrong");
                            return;
                        }
                    }
                    case 3 -> {
                        // Call fetch bookings method
                        System.out.println("Fetching your bookings...");
                        userBookingService.fetchBookings();
                    }
                    case 4 -> {
                        // Call book ticket method
                        System.out.println("Type your source station");
                        String source = scanner.next();
                        System.out.println("Type your destination station");
                        String destination = scanner.next();
                        List<Train> trains = userBookingService.getTrains(source, destination);
                        int index = 1;
                        for (Train t : trains) {
                            System.out.println(index + "Train id: " + t.getTrainId());
                            for (Map.Entry<String, String> entry : t.getStationTimes().entrySet()) {
                                System.out.println("Station: " + entry.getKey() + "time: " + entry.getValue());
                            }
                            index++;
                        }
                        System.out.println("Select a train to book by typing 1,2,3...");
                        try {
                            trainSelectedForBooking = trains.get(scanner.nextInt() - 1);
                            System.out.println(trainSelectedForBooking);
                        } catch (Exception e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                    case 5 -> {
                        //Seat booking method
                        if (trainSelectedForBooking == null) {
                            System.out.println("No train selected. Please choose option 4 first.");
                            break;
                        }
                        System.out.println("Select a seat to book");
                        List<List<Integer>> seats = userBookingService.fetchSeats(trainSelectedForBooking);
                        for (List<Integer> seatRow : seats) {
                            for (Integer seat : seatRow) {
                                System.out.print(seat + " ");
                            }
                            System.out.println();
                        }
                        System.out.println("Select the seat by typing row and column number");
                        System.out.println("Row number:");
                        int row = scanner.nextInt();
                        System.out.println("Column number:");
                        int column = scanner.nextInt();
                        System.out.println("Booking your seat...");
                        Boolean booked = userBookingService.bookTrainSeat(trainSelectedForBooking, row, column);
                        if (booked) {
                            System.out.println("Seat booked successfully");
                        } else {
                            System.out.println("Seat booking failed");
                        }
                    }
                    case 6 -> {
                    }
                    case 7 ->
                        System.out.println("Exiting...");
                    default ->
                        System.out.println("Invalid option. Please try again.");
                }
                // We are taking input from user to perform different operations.
                //
                // Call cancel booking method
            }
        }
    }

    public static void Test() {
        //Arrays.asList creates a fixed-size list backed by the specified array.
        List<Integer> l = Arrays.asList(1, 2, 3, 4, 5);
        //stream() method is used to convert the list into a stream.
        //filter() method is used to filter the elements of the stream based on a given predicate.
        //predicate here is i -> i%2 == 0 which checks if the number is even. It is a lambda expression. It is a functional interface. In Java 8, functional interfaces can be implemented using lambda expressions. They are first class citizens in Java 8 which means we can pass them as parameters to methods, return them from methods, and assign them to variables.
        //lambda expression is a short block of code which takes in parameters and returns a value.
        //collect() method is used to collect the filtered elements back into a list.
        //Collectors.toList() is a static method from the Collectors class that provides a collector
        //which accumulates the input elements into a new List.
        List<Integer> l1 = l.stream().filter(i -> i % 2 == 0).collect(Collectors.toList());
    }
}
